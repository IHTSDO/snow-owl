grammar com.b2international.snowowl.snomed.ecl.Ecl hidden(WS, ML_COMMENT, SL_COMMENT)

generate ecl "http://www.b2international.com/snowowl/snomed/Ecl"

import 'http://www.eclipse.org/emf/2002/Ecore' as ecore

ExpressionConstraint:
	OrExpressionConstraint;

OrExpressionConstraint returns ExpressionConstraint:
	AndExpressionConstraint ({OrExpressionConstraint.left=current} OR right=AndExpressionConstraint)*;
	
AndExpressionConstraint returns ExpressionConstraint:
	ExclusionExpressionConstraint ({AndExpressionConstraint.left=current} AndOperator right=ExclusionExpressionConstraint)*;
	
ExclusionExpressionConstraint returns ExpressionConstraint:
	RefinedExpressionConstraint ({ExclusionExpressionConstraint.left=current} MINUS right=RefinedExpressionConstraint)?;
	
RefinedExpressionConstraint returns ExpressionConstraint:
	DottedExpressionConstraint ({RefinedExpressionConstraint.constraint=current} COLON refinement=Refinement)?;
	
DottedExpressionConstraint returns ExpressionConstraint:
	SimpleExpressionConstraint ({DottedExpressionConstraint.constraint=current} DOT attribute=Attribute)*;

SimpleExpressionConstraint returns ExpressionConstraint:
	ChildOf | DescendantOf | DescendantOrSelfOf | ParentOf | AncestorOf | AncestorOrSelfOf | FocusConcept;
	
FocusConcept returns ExpressionConstraint:
	MemberOf | ConceptReference | Any | NestedExpression;
	
ChildOf:
	LT_EM constraint=FocusConcept;

DescendantOf:
	LT constraint=FocusConcept;

DescendantOrSelfOf:
	DBL_LT constraint=FocusConcept;

ParentOf:
	GT_EM constraint=FocusConcept;
	
AncestorOf:
	GT constraint=FocusConcept;
	
AncestorOrSelfOf:
	DBL_GT constraint=FocusConcept;

MemberOf:
	CARET constraint=(ConceptReference | Any);

ConceptReference:
	id=SnomedIdentifier (PIPE term=Term PIPE)?;
	
Any: 
	WILDCARD {Any};

Refinement:
	OrRefinement;

OrRefinement returns Refinement:
	AndRefinement -> ({OrRefinement.left=current} OR right=AndRefinement)*;

AndRefinement returns Refinement:
	SubRefinement -> ({AndRefinement.left=current} AndOperator right=SubRefinement)*;
	
SubRefinement returns Refinement:
	AttributeConstraint | AttributeGroup | NestedRefinement;
	
NestedRefinement:
	ROUND_OPEN nested=Refinement ROUND_CLOSE;
	
AttributeGroup:
	(cardinality=Cardinality)? CURLY_OPEN refinement=AttributeSet CURLY_CLOSE;
	
AttributeSet returns Refinement:
	OrAttributeSet;
	
OrAttributeSet returns Refinement:
	AndAttributeSet ({OrRefinement.left=current} OR right=AndAttributeSet)*;
	
AndAttributeSet returns Refinement:
	SubAttributeSet ({AndRefinement.left=current} AndOperator right=SubAttributeSet)*;
	
SubAttributeSet returns Refinement:
	AttributeConstraint | NestedAttributeSet;
	
NestedAttributeSet returns NestedRefinement:
	ROUND_OPEN nested=AttributeSet ROUND_CLOSE;
	
AttributeConstraint:
	(cardinality=Cardinality)? (reversed?=REVERSED)? attribute=Attribute comparison=Comparison;
	
Attribute returns ExpressionConstraint:
	AttributeDescendantOf | AttributeDescendantOrSelfOf | ConceptReference | Any;

AttributeDescendantOf returns DescendantOf:
	LT constraint=(ConceptReference | Any);
	
AttributeDescendantOrSelfOf returns DescendantOrSelfOf:
	DBL_LT constraint=(ConceptReference | Any);

Cardinality:
	SQUARE_OPEN min=NonNegativeInteger TO max=MaxValue SQUARE_CLOSE;

Comparison:
	AttributeComparison | DataTypeComparison;
	
AttributeComparison:
	AttributeValueEquals | AttributeValueNotEquals;

DataTypeComparison:
	StringValueEquals | StringValueNotEquals;

AttributeValueEquals:
	EQUAL constraint=SimpleExpressionConstraint;

AttributeValueNotEquals:
	NOT_EQUAL constraint=SimpleExpressionConstraint;
	
StringValueEquals:
	EQUAL value=STRING;
	
StringValueNotEquals:
	NOT_EQUAL value=STRING;
	
NestedExpression:
	ROUND_OPEN nested=ExpressionConstraint ROUND_CLOSE;

// hidden grammar rules
SnomedIdentifier 	hidden() : DIGIT_NONZERO (DIGIT_NONZERO|ZERO)(DIGIT_NONZERO|ZERO)(DIGIT_NONZERO|ZERO)(DIGIT_NONZERO|ZERO)(DIGIT_NONZERO|ZERO)+;
Term 				hidden() : (TermCharacter)+ (WS+ (TermCharacter)+)*;
TermCharacter 		hidden() : LT|GT
								|DBL_LT|DBL_GT
								|LT_EM|GT_EM
								|AND|OR|NOT|MINUS
								|ZERO|DIGIT_NONZERO
								|LETTER|CARET
								|EQUAL|NOT_EQUAL|PLUS
								|CURLY_OPEN|CURLY_CLOSE
								|ROUND_OPEN|ROUND_CLOSE
								|SQUARE_OPEN|SQUARE_CLOSE
								|DOT|COLON|COMMA
								|REVERSED|TO
								|WILDCARD
								|OTHER_CHARACTER;
NonNegativeInteger returns ecore::EInt
					hidden() : ZERO | DIGIT_NONZERO (DIGIT_NONZERO|ZERO)*;
MaxValue 		   returns ecore::EInt
					hidden() : NonNegativeInteger | WILDCARD;
AndOperator			hidden() : AND | COMMA;

// ---TERMINALS---

// ECL terminals
terminal REVERSED				: 'R';
terminal TO						: '..';

// bool operators
terminal AND 					: 'AND';
terminal OR 					: 'OR';
terminal MINUS					: 'MINUS';

// numeric terminals
terminal ZERO 					: '0';
terminal DIGIT_NONZERO  		: '1'..'9';

// character terminals
terminal LETTER					: ('a'..'z' | 'A'..'Z');
terminal PIPE 					: '|';
terminal COLON 					: ':';
terminal CURLY_OPEN 			: '{';
terminal CURLY_CLOSE			: '}';
terminal COMMA					: ',';
terminal ROUND_OPEN 			: '(';
terminal ROUND_CLOSE 			: ')';
terminal SQUARE_OPEN 			: '[';
terminal SQUARE_CLOSE 			: ']';
terminal PLUS 					: '+';
terminal CARET 					: '^';
terminal NOT 					: '!';
terminal DOT					: '.';
terminal WILDCARD 				: '*';
terminal EQUAL					: '=';
terminal NOT_EQUAL				: '!=';
terminal LT						: '<';
terminal GT						: '>';
terminal DBL_LT					: '<<';
terminal DBL_GT					: '>>';
terminal LT_EM					: '<!';
terminal GT_EM					: '>!';

// comment terminals
terminal WS 					: (' '|'\t'|'\n'|'\r');
terminal ML_COMMENT				: '/*' -> '*/';
terminal SL_COMMENT 			: '//' !('\n'|'\r')* ('\r'? '\n')?;

// misc
terminal OTHER_CHARACTER		: !'|';
terminal STRING	: 
			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
			"'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
		; 
